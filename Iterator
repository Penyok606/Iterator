Призначення
Надає спосіб послідовного доступу до всіх елементів складеного об'єкта, не розкриваючи його внутрішнього улаштування.

Мотивація
Складений об'єкт, скажімо список, повинен надавати спосіб доступу до своїх елементів, не розкриваючи їхню внутрішню структуру. Більш того, іноді треба обходити список по-різному, у залежності від задачі, що вирішується. При цьому немає ніякого бажання засмічувати інтерфейс класу Список усілякими операціями для усіх потрібних варіантів обходу, навіть якщо їх усі можна передбачити заздалегідь. Крім того, іноді треба, щоб в один момент часу існувало декілька активних операцій обходу списку.

Все це призводить до необхідності реалізації шаблону Ітератор. Його основна ідея у тому, щоб за доступ до елементів та обхід списку відповідав не сам список, а окремий об'єкт-ітератор. У класі Ітератор означений інтерфейс для доступу до елементів списку. Об'єкт цього класу прослідковує поточний елемент, тобто він володіє інформацією, які з елементів вже відвідувались.

Застосовність
Можна використовувати шаблон Ітератор у випадках:

для доступу до змісту агрегованих об'єктів не розкриваючи їхнє внутрішнє улаштування;
для підтримки декількох активних обходів одного й того ж агрегованого об'єкта;
для подання уніфікованого інтерфейсу з метою обходу різноманітних агрегованих структур (тобто для підтримки поліморфної ітерації).

Переваги
Спільний інтерфейс використання
Перебір колекції
Недоліки
Основною проблемою ітераторів є те, що реалізація ітераторів може бути складною

#include <iostream>

using namespace std;

// вузол, що є частиною списку
struct Node
{
	double item;
	Node* next;
	Node(double x, Node* link = 0) :
		item(x), next(link) {}
};
// «примітивний» ітератор списку
class listIter
{
private:
	Node* p;
public:
	listIter() :p(0) {}
	listIter(Node* ptr) : p(ptr) {}
	double& operator*() { return p->item; }
	listIter& operator++() { p = p->next; return *this; }
	bool operator!=(const listIter& a) { return p != a.p; }
};
// інтерфейс колекції, яка підтримує ітератор
class List
{
private:
	Node * first;
	Node * last;
public:
	List()
	{
		first = last = new Node(0);
	}
	~List()
	{
		while (first != last)
		{
			Node * victim = first;
			first = first->next;
			delete victim;
		}
		delete first;
	}
	List& add(double el)
	{
		last = last->next = new Node(el);
		return *this;
	}
	listIter begin()
	{
		return listIter(first->next);
	}
	listIter end()
	{
		return listIter();
	}
};
void main()
{
	List list;
	list.add(4).add(2);
	listIter iter = list.begin();
	while (iter != list.end())
	{
		cout << *iter;
		++iter;
	}

	for (listIter iter2 = list.begin(); iter2 != list.end(); ++iter2)
	{
		cout << *iter2;
	}
}
